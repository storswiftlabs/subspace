// This file is part of Substrate.

// Copyright (C) Parity Technologies (UK) Ltd.
// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program. If not, see <https://www.gnu.org/licenses/>.

//! # MMR offchain gadget
//!
//! The MMR offchain gadget is run alongside `pallet-mmr` to assist it with offchain
//! canonicalization of finalized MMR leaves and nodes.
//! The gadget should only be run on nodes that have Indexing API enabled (otherwise
//! `pallet-mmr` cannot write to offchain and this gadget has nothing to do).
//!
//! The runtime `pallet-mmr` creates one new MMR leaf per block and all inner MMR parent nodes
//! generated by the MMR when adding said leaf. MMR nodes are stored both in:
//! - on-chain storage - hashes only; not full leaf content;
//! - off-chain storage - via Indexing API, full leaf content (and all internal nodes as well) is
//!   saved to the Off-chain DB using a key derived from `parent_hash` and node index in MMR. The
//!   `parent_hash` is also used within the key to avoid conflicts and overwrites on forks (leaf
//!   data is only allowed to reference data coming from parent block).
//!
//! This gadget is driven by block finality and in responsible for pruning stale forks from
//! offchain db, and moving finalized forks under a "canonical" key based solely on node `pos`
//! in the MMR.

#![warn(missing_docs)]

mod aux_schema;
mod offchain_mmr;
// #[cfg(test)]
// pub mod test_utils;

use crate::offchain_mmr::OffchainMmr;
use futures::StreamExt;
use log::{debug, error, info, trace, warn};
use sc_client_api::{
    Backend, BlockchainEvents, FinalityNotification, FinalizeSummary, ImportNotifications,
};
use sc_consensus_subspace::notification::{
    self, SubspaceNotificationSender, SubspaceNotificationStream,
};
use sc_offchain::OffchainDb;
use sc_utils::mpsc::{tracing_unbounded, TracingUnboundedReceiver, TracingUnboundedSender};
use sp_api::ProvideRuntimeApi;
use sp_blockchain::{Backend as BackendT, HeaderBackend, HeaderMetadata};
use sp_core::H256 as MmrRootHash;
use sp_mmr_primitives::{utils, LeafIndex, MmrApi};
use sp_runtime::traits::{Block, CheckedSub, Header, NumberFor, One};
use sp_runtime::Saturating;
use std::error::Error;
use std::marker::PhantomData;
use std::sync::Arc;

/// Logging target for the mmr gadget.
pub const LOG_TARGET: &str = "mmr";

/// A convenience MMR client trait that defines all the type bounds a MMR client
/// has to satisfy and defines some helper methods.
pub trait MmrClient<B, BE>:
    BlockchainEvents<B> + HeaderBackend<B> + HeaderMetadata<B> + ProvideRuntimeApi<B>
where
    B: Block,
    BE: Backend<B>,
    Self::Api: MmrApi<B, MmrRootHash, NumberFor<B>>,
{
    /// Get the block number where the mmr pallet was added to the runtime.
    fn first_mmr_block_num(
        &self,
        block_hash: B::Hash,
        block_number: NumberFor<B>,
    ) -> Option<NumberFor<B>> {
        match self.runtime_api().mmr_leaf_count(block_hash) {
            Ok(Ok(mmr_leaf_count)) => {
                match utils::first_mmr_block_num::<B::Header>(block_number, mmr_leaf_count) {
                    Ok(first_mmr_block) => {
                        debug!(
                            target: LOG_TARGET,
                            "pallet-mmr detected at block {:?} with genesis at block {:?}",
                            block_number,
                            first_mmr_block
                        );
                        Some(first_mmr_block)
                    }
                    Err(e) => {
                        error!(
                            target: LOG_TARGET,
                            "Error calculating the first mmr block: {:?}", e
                        );
                        None
                    }
                }
            }
            _ => {
                trace!(
                    target: LOG_TARGET,
                    "pallet-mmr not detected at block {:?} ...",
                    block_number,
                );
                None
            }
        }
    }
}

impl<B, BE, T> MmrClient<B, BE> for T
where
    B: Block,
    BE: Backend<B>,
    T: BlockchainEvents<B> + HeaderBackend<B> + HeaderMetadata<B> + ProvideRuntimeApi<B>,
    T::Api: MmrApi<B, MmrRootHash, NumberFor<B>>,
{
    // empty
}

struct OffchainMmrBuilder<B: Block, BE: Backend<B>, C> {
    backend: Arc<BE>,
    client: Arc<C>,
    offchain_db: OffchainDb<BE::OffchainStorage>,
    indexing_prefix: Vec<u8>,

    _phantom: PhantomData<B>,
}

/// A MMR Gadget.
pub struct MmrGadget<B: Block, BE: Backend<B>, C> {
    import_notifications: ImportNotifications<B>,
    canonicalized_block_sender: SubspaceNotificationSender<B::Header>,
    offchain_mmr_builder: Option<OffchainMmrBuilder<B, BE, C>>,
}

impl<B, BE, C> MmrGadget<B, BE, C>
where
    B: Block,
    <B::Header as Header>::Number: Into<LeafIndex>,
    BE: Backend<B>,
    C: MmrClient<B, BE>,
    C::Api: MmrApi<B, MmrRootHash, NumberFor<B>>,
{
    pub async fn run(mut self) {
        let OffchainMmrBuilder {
            backend,
            client,
            offchain_db,
            indexing_prefix,
            ..
        } = self.offchain_mmr_builder.take().expect("");
        let (first_mmr_block_num, best_canonicalized) = match Self::init_block_number(
            &client,
            &backend,
            &mut self.import_notifications,
        )
        .await
        {
            Some(n) => n,
            None => return,
        };
        let mut offchain_mmr = OffchainMmr::new(
            backend,
            client,
            offchain_db,
            indexing_prefix,
            first_mmr_block_num,
            best_canonicalized,
        );

        let mut first = true;
        loop {
            match self.next_block(&offchain_mmr).await {
                Ok(Some(notification)) => {
                    let header = notification.header.clone();
                    if first {
                        // We need to make sure all blocks leading up to current notification
                        // have also been canonicalized.
                        offchain_mmr.canonicalize_catch_up(&notification);
                        first = false;
                    }
                    offchain_mmr.canonicalize_and_prune(notification);
                    self.canonicalized_block_sender.notify(|| header.clone());
                }
                Ok(None) => break,
                Err(err) => {
                    error!(
                        target: LOG_TARGET,
                        "MmrGadget met unexpected error {err:?}",
                    );
                    break;
                }
            }
        }
    }

    async fn init_block_number(
        client: &Arc<C>,
        backend: &Arc<BE>,
        import_notification_stream: &mut ImportNotifications<B>,
    ) -> Option<(NumberFor<B>, NumberFor<B>)> {
        while let Some(import_notification) = import_notification_stream.next().await {
            let block_hash = import_notification.header.hash();
            let block_number = *import_notification.header.number();
            if let Some(first_mmr_block_num) = client.first_mmr_block_num(block_hash, block_number)
            {
                let mut best_canonicalized = first_mmr_block_num.saturating_sub(One::one());
                best_canonicalized = aux_schema::load_or_init_state::<B, BE>(
                    &*backend,
                    best_canonicalized,
                )
                .map_err(|e| error!(target: LOG_TARGET, "Error loading state from aux db: {:?}", e))
                .ok()?;
                return Some((first_mmr_block_num, best_canonicalized));
            }
        }
        error!(
            target: LOG_TARGET,
            "Block import notifications stream closed unexpectedly. \
            Couldn't build the canonicalization engine",
        );
        None
    }

    async fn next_block(
        &mut self,
        offchain_mmr: &OffchainMmr<B, BE, C>,
    ) -> Result<Option<FinalityNotification<B>>, Box<dyn Error>> {
        let best_canonicalized = offchain_mmr.best_canonicalized;
        while let Some(import_notification) = self.import_notifications.next().await {
            if !import_notification.is_new_best {
                continue;
            }
            let block_number = match import_notification
                .header
                .number()
                .checked_sub(&10u32.into())
            {
                Some(n) => n,
                None => continue,
            };
            if best_canonicalized >= block_number {
                continue;
            }
            let best_canonicalized_hash = offchain_mmr
                .client
                .hash(best_canonicalized)?
                .ok_or_else(|| {
                    sp_blockchain::Error::Backend(format!(
                        "Consensus block hash for #{best_canonicalized:?} not found"
                    ))
                })?;
            let block_hash = offchain_mmr.client.hash(block_number)?.ok_or_else(|| {
                sp_blockchain::Error::Backend(format!(
                    "Consensus block hash for #{block_number:?} not found"
                ))
            })?;
            let block_header = offchain_mmr.client.header(block_hash)?.ok_or_else(|| {
                sp_blockchain::Error::Backend(format!(
                    "Consensus block header for #{block_hash:?} not found"
                ))
            })?;

            let route_from_finalized = sp_blockchain::tree_route(
                offchain_mmr.backend.blockchain(),
                best_canonicalized_hash,
                block_hash,
            )?;
            let finalized = route_from_finalized
                .enacted()
                .iter()
                .map(|elem| elem.hash)
                .collect::<Vec<_>>();
            let stale_heads = offchain_mmr
                .backend
                .blockchain()
                .displaced_leaves_after_finalizing(block_number)?;
            let summary = FinalizeSummary {
                header: block_header,
                finalized,
                stale_heads,
            };
            let (sender, _) = tracing_unbounded("empty", 0);
            return Ok(Some(FinalityNotification::from_summary(summary, sender)));
        }
        Ok(None)
    }

    /// Create and run the MMR gadget.
    pub fn new(
        client: Arc<C>,
        backend: Arc<BE>,
        indexing_prefix: Vec<u8>,
    ) -> (Self, SubspaceNotificationStream<B::Header>) {
        let offchain_db = match backend.offchain_storage() {
            Some(offchain_storage) => OffchainDb::new(offchain_storage),
            None => {
                panic!("Can't spawn a MmrGadget for a node without offchain storage.");
            }
        };
        let import_notifications = client.import_notification_stream();

        let (canonicalized_block_sender, canonicalized_block_receiver) =
            notification::channel("mmr_canonicalized_block_channel");

        let offchain_mmr_builder = OffchainMmrBuilder {
            backend,
            client,
            offchain_db,
            indexing_prefix,
            _phantom: Default::default(),
        };

        let mmr_gadget = MmrGadget::<B, BE, C> {
            import_notifications,
            canonicalized_block_sender,
            offchain_mmr_builder: Some(offchain_mmr_builder),
        };

        (mmr_gadget, canonicalized_block_receiver)
    }
}

// #[cfg(test)]
// mod tests {
//     use crate::test_utils::run_test_with_mmr_gadget;
//     use sp_runtime::generic::BlockId;
//     use std::time::Duration;

//     #[test]
//     fn mmr_first_block_is_computed_correctly() {
//         // Check the case where the first block is also the first block with MMR.
//         run_test_with_mmr_gadget(|client| async move {
//             // G -> A1 -> A2
//             //      |
//             //      | -> first mmr block

//             let a1 = client
//                 .import_block(&BlockId::Number(0), b"a1", Some(0))
//                 .await;
//             let a2 = client
//                 .import_block(&BlockId::Hash(a1.hash()), b"a2", Some(1))
//                 .await;

//             client.finalize_block(a1.hash(), Some(1));
//             tokio::time::sleep(Duration::from_millis(200)).await;
//             // expected finalized heads: a1
//             client.assert_canonicalized(&[&a1]);
//             client.assert_not_pruned(&[&a2]);
//         });

//         // Check the case where the first block with MMR comes later.
//         run_test_with_mmr_gadget(|client| async move {
//             // G -> A1 -> A2 -> A3 -> A4 -> A5 -> A6
//             //                        |
//             //                        | -> first mmr block

//             let a1 = client.import_block(&BlockId::Number(0), b"a1", None).await;
//             let a2 = client
//                 .import_block(&BlockId::Hash(a1.hash()), b"a2", None)
//                 .await;
//             let a3 = client
//                 .import_block(&BlockId::Hash(a2.hash()), b"a3", None)
//                 .await;
//             let a4 = client
//                 .import_block(&BlockId::Hash(a3.hash()), b"a4", Some(0))
//                 .await;
//             let a5 = client
//                 .import_block(&BlockId::Hash(a4.hash()), b"a5", Some(1))
//                 .await;
//             let a6 = client
//                 .import_block(&BlockId::Hash(a5.hash()), b"a6", Some(2))
//                 .await;

//             client.finalize_block(a5.hash(), Some(2));
//             tokio::time::sleep(Duration::from_millis(200)).await;
//             // expected finalized heads: a4, a5
//             client.assert_canonicalized(&[&a4, &a5]);
//             client.assert_not_pruned(&[&a6]);
//         });
//     }

//     #[test]
//     fn does_not_panic_on_invalid_num_mmr_blocks() {
//         run_test_with_mmr_gadget(|client| async move {
//             // G -> A1
//             //      |
//             //      | -> first mmr block

//             let a1 = client
//                 .import_block(&BlockId::Number(0), b"a1", Some(0))
//                 .await;

//             // Simulate the case where the runtime says that there are 2 mmr_blocks when in fact
//             // there is only 1.
//             client.finalize_block(a1.hash(), Some(2));
//             tokio::time::sleep(Duration::from_millis(200)).await;
//             // expected finalized heads: -
//             client.assert_not_canonicalized(&[&a1]);
//         });
//     }
// }
